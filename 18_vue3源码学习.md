

## Vue3源码学习



## 真实的DOM渲染

我们传统的前端开发中，我们是编写自己的HTML，形成一个dom树，浏览器识别到我们的dom树，最终被渲染到浏览器上的，那么它是什么样的过程呢？

![image-20250731220136023](./assets/18_vue3源码学习.assets/image-20250731220136023.png)





## 虚拟DOM的优势

目前框架都会引入虚拟DOM来对真实的DOM进行抽象，这样做有很多的好处：

首先是可以对真实的元素节点进行抽象，抽象成VNode（虚拟节点），这样方便后续对其进行各种操作： 

- 因为对于直接操作DOM来说是有很多的限制的，比如diff、clone等等(element的属性太多了)，但是使用JavaScript编程语言来操作这 些，就变得非常的简单； 
- 我们可以使用JavaScript来表达非常多的逻辑，而对于DOM本身来说是非常不方便的；

其次是方便实现跨平台，包括你可以将VNode节点渲染成任意你想要的节点 

- 如渲染在canvas、WebGL、SSR、Native（iOS、Android）上； 
- 并且Vue允许你开发属于自己的渲染器（renderer），在其他的平台上渲染；

实现跨平台，将一些虚拟dom转成控件，比如ios，安卓，button控件（安卓），或者uibutton控件（ios）

vue源码比较复杂，但是本质上做的就是这个事情





## 虚拟DOM的渲染过程

![image-20250731220456886](./assets/18_vue3源码学习.assets/image-20250731220456886.png)

![image-20250731220501875](./assets/18_vue3源码学习.assets/image-20250731220501875.png)





## 三大核心系统

事实上Vue的源码包含三大核心： 

- Compiler模块：编译模板系统（把template中的代码编译成render函数生成虚拟节点）； 
-  Runtime模块：也可以称之为Renderer模块，真正渲染的模块； 
- Reactivity模块：响应式系统；

![image-20250731220518638](./assets/18_vue3源码学习.assets/image-20250731220518638.png)

![image-20250731220524050](./assets/18_vue3源码学习.assets/image-20250731220524050.png)





## 三大系统协同工作

三个系统之间如何协同工作呢：

![image-20250731220638651](./assets/18_vue3源码学习.assets/image-20250731220638651.png)





## 实现Mini-Vue

这里我们实现一个简洁版的Mini-Vue框架，该Vue包括三个模块： 

- 渲染系统模块； 
- 可响应式系统模块； 
- 应用程序入口模块；



## 渲染系统实现

渲染系统，该模块主要包含三个功能： 

- 功能一：h函数，用于返回一个VNode对象； 
- 功能二：mount函数，用于将VNode挂载到DOM上； 
- 功能三：patch函数，用于对两个VNode进行对比，决定如何处理新的VNode；

./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./render.js"></script>
  <script>
    // 1.通过h函数来创建一个vnode
    const vnode = h('div', {class: 'wts'}, [
      h('h2', null, 'hello world'),
      h('p', null, 'this is a paragraph')
    ])
  </script>
</body>
</html>
```



### h函数 – 生成VNode

h函数的实现： 

- 直接返回一个VNode对象即可

./render.js

```js
const h = (tag, props, children) => {
  // 返回的就是vnode对象
  return {
    tag,
    props,
    children
  }
}
```

上面已经实现了h函数

这就是我们的vnode了

![image-20250801201650061](./assets/18_vue3源码学习.assets/image-20250801201650061.png)

上面就是虚拟dom了

接下来需要把虚拟节点转换成真实dom，并且展示在页面





### Mount函数 – 挂载VNode

mount函数的实现：

第一步：根据tag，创建HTML元素，并且存储 到vnode的el中；

第二步：处理props属性 

- 如果以on开头，那么监听事件； 
- 普通属性直接通过 setAttribute 添加即可；

第三步：处理子节点 

- 如果是字符串节点，那么直接设置 textContent； 
- 如果是数组节点，那么遍历调用 mount 函 数；

./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./render.js"></script>
  <script>
    // 1.通过h函数来创建一个vnode
    const vnode = h('div', {class: 'wts'}, [
      h('h2', null, 'hello world'),
      h('p', null, 'this is a paragraph')
    ])
    console.log(vnode);

    // 2.通过mount函数将vnode怪哉到div#app上
    mount(vnode, document.querySelector('#app'));
  </script>
</body>
</html>
```

./render.js

```js
const h = (tag, props, children) => {
  // 返回的就是vnode对象
  return {
    tag,
    props,
    children
  }
}

const mount = (vnode, container) => {
  // vnode保留一份真实的DOM元素
  const el = vnode.el = document.createElement(vnode.tag);

  // 设置属性
  if (vnode.props) {
    for (const key in vnode.props) {
      const value = vnode.props[key];
      // 如果是事件监听器
      if (key.startsWith('on')) {
        el.addEventListener(key.slice(2).toLowerCase(), value)
      } else {
        // 普通属性
        el.setAttribute(key, value)
      }
      
    }
  }

  // 3.处理子节点
  if (vnode.children) {
    if (typeof vnode.children === 'string') {
      // 如果是文本节点
      el.textContent = vnode.children;
    } else {
      // 如果是数组节点
      vnode.children.forEach(child => {
        mount(child, el);
      });
    }
  }

  // 4.将el添加到容器中
  container.appendChild(el);
}
```



### Patch函数 – 对比两个VNode

patch函数的实现，分为两种情况 

n1和n2是不同类型的节点： 

- 找到n1的el父节点，删除原来的n1节点的el； 
- 挂载n2节点到n1的el父节点上；

n1和n2节点是相同的节点： 

- 处理props的情况 
  - 先将新节点的props全部挂载到el上； 
  - 判断旧节点的props是否不需要在新节点上，如果不需要，那么删除对应的属性； 
- 处理children的情况
  - 如果新节点是一个字符串类型，那么直接调用 el.textContent = newChildren； 
  - 如果新节点不同一个字符串类型：
    - 旧节点是一个字符串类型 
      - 将el的textContent设置为空字符串； 
      - 就节点是一个字符串类型，那么直接遍历新节点，挂载到el上；
    - 旧节点也是一个数组类型 
      - 取出数组的最小长度； 
      - 遍历所有的节点，新节点和旧节点进行path操作； 
      - 如果新节点的length更长，那么剩余的新节点进行挂载操作； 
      - 如果旧节点的length更长，那么剩余的旧节点进行卸载操作；



#### 如果节点不同

./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./render.js"></script>
  <script>
    // 1.通过h函数来创建一个vnode
    const vnode = h('div', {class: 'wts'}, [
      h('h2', null, '当前计数'),
      h('button', {onClick: function () {}}, '+1')
    ])
    console.log(vnode);

    // 2.通过mount函数将vnode怪哉到div#app上
    mount(vnode, document.querySelector('#app'));

    // 3.创建新的vnode
    const vnode1 = h('h2', { class: 'coderwts' }, '哈哈哈')

    // 为了看的更清楚一些用计时器
    setTimeout(() => {
      patch(vnode, vnode1)
    }, 2000)
  </script>
</body>
</html>
```



./render.js

```js
const h = (tag, props, children) => {
  // 返回的就是vnode对象
  return {
    tag,
    props,
    children
  }
}

const mount = (vnode, container) => {
  // vnode保留一份真实的DOM元素
  const el = vnode.el = document.createElement(vnode.tag);

  // 设置属性
  if (vnode.props) {
    for (const key in vnode.props) {
      const value = vnode.props[key];
      // 如果是事件监听器
      if (key.startsWith('on')) {
        el.addEventListener(key.slice(2).toLowerCase(), value)
      } else {
        // 普通属性
        el.setAttribute(key, value)
      }
      
    }
  }

  // 3.处理子节点
  if (vnode.children) {
    if (typeof vnode.children === 'string') {
      // 如果是文本节点
      el.textContent = vnode.children;
    } else {
      // 如果是数组节点
      vnode.children.forEach(child => {
        mount(child, el);
      });
    }
  }

  // 4.将el添加到容器中
  container.appendChild(el);
}

const patch = (n1, n2) => {
  if (n1.tag !== n2.tag) {
    const n1ElParent = n1.el.parentElement;
    n1ElParent.removeChild(n1.el)
    mount(n2, n1ElParent)
  } else {

  }
}
```



#### 如果节点相同，但是属性不同，内容也不同

./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./render.js"></script>
  <script>
    // 1.通过h函数来创建一个vnode
    const vnode = h('div', {class: 'wts', id: 'aaa'}, [
      h('h2', null, '当前计数'),
      h('button', {onClick: function () {}}, '+1')
    ])
    console.log(vnode);

    // 2.通过mount函数将vnode怪哉到div#app上
    mount(vnode, document.querySelector('#app'));

    // 3.创建新的vnode
    // const vnode1 = h('h2', { class: 'coderwts' }, '哈哈哈')
    const vnode1 = h('div', { class: 'coderwts', id: 'aaa' }, '哈哈哈')

    // 为了看的更清楚一些用计时器
    setTimeout(() => {
      patch(vnode, vnode1)
    }, 2000)
  </script>
</body>
</html>
```

./render.js

```js
const h = (tag, props, children) => {
  // 返回的就是vnode对象
  return {
    tag,
    props,
    children
  }
}

const mount = (vnode, container) => {
  // vnode保留一份真实的DOM元素
  const el = vnode.el = document.createElement(vnode.tag);

  // 设置属性
  if (vnode.props) {
    for (const key in vnode.props) {
      const value = vnode.props[key];
      // 如果是事件监听器
      if (key.startsWith('on')) {
        el.addEventListener(key.slice(2).toLowerCase(), value)
      } else {
        // 普通属性
        el.setAttribute(key, value)
      }
      
    }
  }

  // 3.处理子节点
  if (vnode.children) {
    if (typeof vnode.children === 'string') {
      // 如果是文本节点
      el.textContent = vnode.children;
    } else {
      // 如果是数组节点
      vnode.children.forEach(child => {
        mount(child, el);
      });
    }
  }

  // 4.将el添加到容器中
  container.appendChild(el);
}

const patch = (n1, n2) => {
  if (n1.tag !== n2.tag) {
    const n1ElParent = n1.el.parentElement;
    n1ElParent.removeChild(n1.el)
    mount(n2, n1ElParent)
  } else {
    // 1.取出element对象并且在n2中保存(当前n1.el在mount的时候加进去了，但是n2没有，所以这里加上)
    const el = n2.el = n1.el

    // 2.处理props
    const oldProps = n1.props || {}
    const newProps = n2.props || {}
    // 2.1获取所有的newProps添加到el
    for(const key in newProps) {
      const oldValue = oldProps[key]
      const newValue = newProps[key]
      if (oldValue !== newValue) {
        if (key.startsWith('on')) {
          el.addEventListener(key.slice(2).toLowerCase(), newValue)
        } else {
          // 普通属性
          el.setAttribute(key, newValue)
        }
      }
    }

    // 2.2删除旧的props
    for(const key in oldProps) {
      if (!(key in newProps)) {
        if (key.startsWith('on')) {
          const value = oldProps[key]
          el.removeEventListener(key.slice(2).toLowerCase(), value)
        } else {
          // 普通属性
          el.removeAttribute(key)
        }
      }
    }


    // 3.处理Children
  }
}
```



#### 如果children不同

./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./render.js"></script>
  <script>
    // 1.通过h函数来创建一个vnode
    const vnode = h('div', {class: 'wts', id: 'aaa'}, [
      h('h2', null, '当前计数'),
      h('button', {onClick: function () {}}, '+1')
    ])
    console.log(vnode);

    // 2.通过mount函数将vnode怪哉到div#app上
    mount(vnode, document.querySelector('#app'));

    // 3.创建新的vnode
    // const vnode1 = h('h2', { class: 'coderwts' }, '哈哈哈')
    const vnode1 = h('div', { class: 'coderwts', id: 'aaa' },  [
      h('h2', null, '当前算数'),
      h('button', {onClick: function () {}}, '-1')
    ])

    // 为了看的更清楚一些用计时器
    setTimeout(() => {
      patch(vnode, vnode1)
    }, 2000)
  </script>
</body>
</html>
```

./render.js

```js
const h = (tag, props, children) => {
  // 返回的就是vnode对象
  return {
    tag,
    props,
    children
  }
}

const mount = (vnode, container) => {
  // vnode保留一份真实的DOM元素
  const el = vnode.el = document.createElement(vnode.tag);

  // 设置属性
  if (vnode.props) {
    for (const key in vnode.props) {
      const value = vnode.props[key];
      // 如果是事件监听器
      if (key.startsWith('on')) {
        el.addEventListener(key.slice(2).toLowerCase(), value)
      } else {
        // 普通属性
        el.setAttribute(key, value)
      }
      
    }
  }

  // 3.处理子节点
  if (vnode.children) {
    if (typeof vnode.children === 'string') {
      // 如果是文本节点
      el.textContent = vnode.children;
    } else {
      // 如果是数组节点
      vnode.children.forEach(child => {
        mount(child, el);
      });
    }
  }

  // 4.将el添加到容器中
  container.appendChild(el);
}

const patch = (n1, n2) => {
  if (n1.tag !== n2.tag) {
    const n1ElParent = n1.el.parentElement;
    n1ElParent.removeChild(n1.el)
    mount(n2, n1ElParent)
  } else {
    // 1.取出element对象并且在n2中保存(当前n1.el在mount的时候加进去了，但是n2没有，所以这里加上)
    const el = n2.el = n1.el

    // 2.处理props
    const oldProps = n1.props || {}
    const newProps = n2.props || {}
    // 2.1获取所有的newProps添加到el
    for(const key in newProps) {
      const oldValue = oldProps[key]
      const newValue = newProps[key]
      if (oldValue !== newValue) {
        if (key.startsWith('on')) {
          el.addEventListener(key.slice(2).toLowerCase(), newValue)
        } else {
          // 普通属性
          el.setAttribute(key, newValue)
        }
      }
    }

    // 2.2删除旧的props
    for(const key in oldProps) {
      if (!(key in newProps)) {
        if (key.startsWith('on')) {
          const value = oldProps[key]
          el.removeEventListener(key.slice(2).toLowerCase(), value)
        } else {
          // 普通属性
          el.removeAttribute(key)
        }
      }
    }


    // 3.处理Children
    const oldChildren = n1.children || []
    const newChildren = n2.children || []

    if (typeof newChildren === 'string') {  // 情况一：newChild是字符串
      // 如果n1的innerHTML和n2的innerHTML相同的话就不用赋值，这属于egeCase
      if(typeof oldChildren === 'string') {
        if (newChildren !== oldChildren) {
          el.textContent = newChildren
        }
      } else {
        el.innerHTML = newChildren
      }
    } else { // 情况二： newChild不是字符串，那就是数组（插槽才是对象，不考虑）
      if (typeof oldChildren === 'string') {
        el.innerHTML = '';
        newChildren.forEach(item => {
          mount(item, el)
        })
      } else { // 两个都是数组
        // oldChildren: [v1, v2, v3]
        // newChildren: [v2, v4, v8, v9]
        // 1.前面有相同节点的原生进行patch操作
        const commonLength = Math.min(oldChildren.length, newChildren.length);
        for(let i = 0; i < commonLength; i++) {
          patch(oldChildren[i], newChildren[i]);
        }

        // 2.newChildren > oldChilren
        if (newChildren.length > oldChildren.length) {
          newChildren.slice(oldChildren.length).forEach(item => {
            mount(item, el)
          })
        }

        // 3.newChildren < oldChildren
        if (newChildren.length < oldChildren.length) {
          oldChildren.slice(newChildren.length).forEach(item => {
            el.removeChild(item.el)
          })
        }
      }
    }
  }
}
```

以上就是渲染器的实现了，接下来实现响应式系统



## 响应式系统

实现一个dep的响应式系统

./reactive.js

```js
class Dep {
  constructor() {
    this.subScribers = new Set();
    
  }
  addEffect(effct) {
    this.subScribers.add(effct)
  }
  notify() {
    this.subScribers.forEach(effct => {
      effct()
    });
  }
}

const info = { counter: 100 }

const dep = new Dep()
function doubleCounter() {
  console.log(info.counter * 2)
}
function powerCounter() {
  console.log(info.counter * info.counter)
}

dep.addEffect(doubleCounter)
dep.addEffect(powerCounter)


info.counter = 200

dep.notify()
```

缺点：需要手动把函数加入到subScribers中等等

代码重新构造了一下，但是和上面的代码效果是一样的

./reactive.js

```js
let activeEffect = null
class Dep {
  constructor() {
    this.subScribers = new Set();
    
  }
  addEffect(effct) {
    this.subScribers.add(effct)
  }
  depend() {
    if (activeEffect) {
      this.subScribers.add(activeEffect)
    }
  }
  notify() {
    this.subScribers.forEach(effct => {
      effct()
    });
  }
}
const info = { counter: 100 }

const dep = new Dep()

function watchEffect(effct) {
  activeEffect = effct;
  dep.depend()
  // 这里要先执行一次
  effct()
  activeEffect = null;
}

watchEffect(function() {
  console.log(info.counter * 2)
})
watchEffect(function () {
  console.log(info.counter * info.counter)
})

info.counter = 200

dep.notify()
```



对不同的属性有依赖的话，需要针对每一个依赖做通知，而不是每一个都通知

所以这个依赖不是随便收集的，而是有多个dep，比如，这个dep是关于counter的，其他的dep是关于name的等等，但是还可能存在foo，foo也是有counter，也有name，需要对foo这里的属性做一个管理，所以我们最好有这样的一个数据结构

![image-20250805141631025](./assets/18_vue3源码学习.assets/image-20250805141631025.png)

上面的这些，实际上先定义了一个map，然后对foo定义了一个数据结构map，然后对info定义了一个数据结构map，接着每一个foo或者info的属性都实例化了dep

所以接下来需要对数据的监听做一个处理



### Vue2的响应式思路

./reactive.js

```js
let activeEffect = null
class Dep {
  constructor() {
    this.subScribers = new Set();
    
  }
  addEffect(effct) {
    this.subScribers.add(effct)
  }
  depend() {
    if (activeEffect) {
      this.subScribers.add(activeEffect)
    }
  }
  notify() {
    this.subScribers.forEach(effct => {
      effct()
    });
  }
}

const targetMap = new WeakMap()
function getDep(target, key) {
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  let dep = depsMap.get(key)
  if (!dep) {
    dep = new Dep()
    depsMap.set(key, dep)
  }
  return dep
}

// 对属性做劫持（vue2）
function reactive(raw) {
  Object.keys(raw).forEach(key => {
    const dep = getDep(raw, key);
    let value = raw[key];
    Object.defineProperty(raw, key, {
      get() {
        dep.depend();
        return value;
      },
      set(newValue) {
        value = newValue
        dep.notify();
      }
    })
  })
  return raw;
}

const info = reactive({ counter: 100, name: 'wts' })
const foo = reactive({height: 1.88})
const dep = new Dep()

function watchEffect(effct) {
  activeEffect = effct;
  // 这里要先执行一次,因为执行后才能收集依赖
  effct()
  activeEffect = null;
}

watchEffect(function() {
  console.log(info.counter * 2)
})
watchEffect(function () {
  console.log(info.counter * info.counter)
})
watchEffect(function () {
  console.log(info.name)
})

info.name = 'www'

```

以上是Vue2的响应式



### Vue3的响应式

./reactive.js

```js
let activeEffect = null
class Dep {
  constructor() {
    this.subScribers = new Set();
    
  }
  addEffect(effct) {
    this.subScribers.add(effct)
  }
  depend() {
    if (activeEffect) {
      this.subScribers.add(activeEffect)
    }
  }
  notify() {
    this.subScribers.forEach(effct => {
      effct()
    });
  }
}

const targetMap = new WeakMap()
function getDep(target, key) {
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  let dep = depsMap.get(key)
  if (!dep) {
    dep = new Dep()
    depsMap.set(key, dep)
  }
  return dep
}

// 对属性做劫持（vue2）
function reactive(raw) {
  let proxy = new Proxy(raw, {
    get(target, key, receiver) {
      let dep = getDep(target, key)
      dep.depend()
      return Reflect.get(target, key, receiver) // 是为了绑定this的
    },
    set(target, key, newValue, receiver) {
      let dep = getDep(target, key)
      Reflect.set(target, key, newValue, receiver)
      dep.notify()
    }
  })
  return proxy;
}

const info = reactive({ counter: 100, name: 'wts' })
const foo = reactive({height: 1.88})
const dep = new Dep()

function watchEffect(effct) {
  activeEffect = effct;
  // 这里要先执行一次
  effct()
  activeEffect = null;
}

watchEffect(function() {
  console.log(info.counter * 2)
})
watchEffect(function () {
  console.log(info.counter * info.counter)
})
watchEffect(function () {
  console.log(info.name)
})

info.name = 'www'
info.name = 'www3'
info.name = 'www4'

```







## 为什么Vue3选择Proxy呢？

Object.definedProperty 是劫持对象的属性时，如果新增元素： 

- 那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理；
  - vue2中如果新增了属性需要使用Vue.$set，实际上就是触发definedProperty


修改对象的不同： 

- 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截； 
- 而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截；

Proxy 能观察的类型比 defineProperty 更丰富 

- has：in操作符的捕获器； 
- deleteProperty：delete 操作符的捕捉器； 
- 等等其他操作；

Proxy 作为新标准将受到浏览器厂商重点持续的性能优化；

缺点：Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9





## 框架外层API设计

这样我们就知道了，从框架的层面来说，我们需要 有两部分内容： 

- createApp用于创建一个app对象； 
- 该app对象有一个mount方法，可以将根组件挂载到某一个dom元素上；

./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./render.js"></script>
  <script src="./reactive.js"></script>
  <script src="./index.js"></script>
  <script>
    // 1.根组件
    const App = {
      data: reactive({
        counter: 0
      }),
      render() {
        return h('div', null, [
          h('h2', null, `当前计数${this.data.counter}`),
          h('button', {
            onclick: () => {
              this.data.counter++
            }
          }, '+1')
        ])
      }
    }

    // 2.挂载根组件
    const app = createApp(App)
    app.mount('#app')
  </script>
</body>
</html>
```

./index.js

```js
function createApp(rootComponent) {
  return {
    mount(selector) {
      const container = document.querySelector(selector);
      let isMounted = false
      let oldVNode = null

      watchEffect(() => {
        if (!isMounted) {
          oldVNode = rootComponent.render();
          mount(oldVNode, container)
          isMounted = true
        } else {
          const newVNode = rootComponent.render()
          patch(oldVNode, newVNode);
          oldVNode = newVNode
        }
      })
    }
  }
}
```



./reactive.js

```js
let activeEffect = null
class Dep {
  constructor() {
    this.subScribers = new Set();
    
  }
  addEffect(effct) {
    this.subScribers.add(effct)
  }
  depend() {
    if (activeEffect) {
      this.subScribers.add(activeEffect)
    }
  }
  notify() {
    this.subScribers.forEach(effct => {
      effct()
    });
  }
}

const targetMap = new WeakMap()
function getDep(target, key) {
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  let dep = depsMap.get(key)
  if (!dep) {
    dep = new Dep()
    depsMap.set(key, dep)
  }
  return dep
}

// 对属性做劫持（vue2）
function reactive(raw) {
  let proxy = new Proxy(raw, {
    get(target, key, receiver) {
      let dep = getDep(target, key)
      dep.depend()
      return Reflect.get(target, key, receiver) // 是为了绑定this的
    },
    set(target, key, newValue, receiver) {
      let dep = getDep(target, key)
      Reflect.set(target, key, newValue, receiver)
      dep.notify()
    }
  })
  return proxy;
}

const info = reactive({ counter: 100, name: 'wts' })
const foo = reactive({height: 1.88})
const dep = new Dep()

function watchEffect(effct) {
  activeEffect = effct;
  // 这里要先执行一次
  effct()
  activeEffect = null;
}

watchEffect(function() {
  console.log(info.counter * 2)
})
watchEffect(function () {
  console.log(info.counter * info.counter)
})
watchEffect(function () {
  console.log(info.name)
})

// info.name = 'www'
// info.name = 'www3'
// info.name = 'www4'

```

./render.js

```js
const h = (tag, props, children) => {
  // 返回的就是vnode对象
  return {
    tag,
    props,
    children
  }
}

const mount = (vnode, container) => {
  // vnode保留一份真实的DOM元素
  const el = vnode.el = document.createElement(vnode.tag);

  // 设置属性
  if (vnode.props) {
    for (const key in vnode.props) {
      const value = vnode.props[key];
      // 如果是事件监听器
      if (key.startsWith('on')) {
        el.addEventListener(key.slice(2).toLowerCase(), value)
      } else {
        // 普通属性
        el.setAttribute(key, value)
      }
    }
  }

  // 3.处理子节点
  if (vnode.children) {
    if (typeof vnode.children === 'string') {
      // 如果是文本节点
      el.textContent = vnode.children;
    } else {
      // 如果是数组节点
      vnode.children.forEach(child => {
        mount(child, el);
      });
    }
  }

  // 4.将el添加到容器中
  container.appendChild(el);
}

const patch = (n1, n2) => {
  if (n1.tag !== n2.tag) {
    const n1ElParent = n1.el.parentElement;
    n1ElParent.removeChild(n1.el)
    mount(n2, n1ElParent)
  } else {
    // 1.取出element对象并且在n2中保存(当前n1.el在mount的时候加进去了，但是n2没有，所以这里加上)
    const el = n2.el = n1.el

    // 2.处理props
    const oldProps = n1.props || {}
    const newProps = n2.props || {}

    // 2.1获取所有的newProps添加到el
    for(const key in newProps) {
      const oldValue = oldProps[key]
      const newValue = newProps[key]
      if (oldValue !== newValue) {
        if (key.startsWith('on')) {
          el.addEventListener(key.slice(2).toLowerCase(), newValue)
        } else {
          // 普通属性
          el.setAttribute(key, newValue)
        }
      }
    }

    // 2.2删除旧的props
    for(const key in oldProps) {

      // 需要把旧的事件删掉
      if (key.startsWith('on')) {
        const value = oldProps[key]
        el.removeEventListener(key.slice(2).toLowerCase(), value)
      }

      if (!(key in newProps)) {
        // 普通属性
        el.removeAttribute(key)
      }
    }


    // 3.处理Children
    const oldChildren = n1.children || []
    const newChildren = n2.children || []

    if (typeof newChildren === 'string') {  // 情况一：newChild是字符串
      // 如果n1的innerHTML和n2的innerHTML相同的话就不用赋值，这属于egeCase
      if(typeof oldChildren === 'string') {
        if (newChildren !== oldChildren) {
          el.textContent = newChildren
        }
      } else {
        el.innerHTML = newChildren
      }
    } else { // 情况二： newChild不是字符串，那就是数组（插槽才是对象，不考虑）
      if (typeof oldChildren === 'string') {
        el.innerHTML = '';
        newChildren.forEach(item => {
          mount(item, el)
        })
      } else { // 两个都是数组
        // oldChildren: [v1, v2, v3]
        // newChildren: [v2, v4, v8, v9]
        // 1.前面有相同节点的原生进行patch操作
        const commonLength = Math.min(oldChildren.length, newChildren.length);
        for(let i = 0; i < commonLength; i++) {
          patch(oldChildren[i], newChildren[i]);
        }

        // 2.newChildren > oldChilren
        if (newChildren.length > oldChildren.length) {
          newChildren.slice(oldChildren.length).forEach(item => {
            mount(item, el)
          })
        }

        // 3.newChildren < oldChildren
        if (newChildren.length < oldChildren.length) {
          oldChildren.slice(newChildren.length).forEach(item => {
            el.removeChild(item.el)
          })
        }
      }
    }
  }
}
```







## 源码阅读之createApp

![image-20250806141045351](./assets/18_vue3源码学习.assets/image-20250806141045351.png)

首先，拿到源码，然后执行yarn install

之后执行npm run dev

就能把项目跑起来，并且打包好

![image-20250806145846600](./assets/18_vue3源码学习.assets/image-20250806145846600.png)

那么项目入口在哪里呢？

![image-20250806145927392](./assets/18_vue3源码学习.assets/image-20250806145927392.png)

当然上面是打包后的入口，真正源码的入口实际上是这个

![image-20250806150134700](./assets/18_vue3源码学习.assets/image-20250806150134700.png)

上面可以看到```export * from '@vue/runtime-dom'```

那么在找到这个文件

![image-20250806150321939](./assets/18_vue3源码学习.assets/image-20250806150321939.png)

这里可以看到非常熟悉的函数，createApp了

现在再回头看这个

![image-20250806150621913](./assets/18_vue3源码学习.assets/image-20250806150621913.png)

他是把packages/vue/src/index.ts打包到packages/vue/dist/vue.global.js这个文件中了，按照上面走的一遍的话，实际上就是把packages中的所有文件都打包到vue.global.js中去了（因为存在互相引用）

创建个文件，并且引入打包后的文件

![image-20250806154624059](./assets/18_vue3源码学习.assets/image-20250806154624059.png)

注意：这里不需要引入.map文件，浏览器会自动引入

接下来我们想知道，当创建了一个组件，并且把这个组件传给createApp的时候，内部做了什么事？挂载的时候又做了什么事情？

createapp在哪里呢

![image-20250806154737135](./assets/18_vue3源码学习.assets/image-20250806154737135.png)

这个是运行时里面（不属于编译模块，也不属于响应式模块）

![image-20250806155603342](./assets/18_vue3源码学习.assets/image-20250806155603342.png)

创建渲染器

![image-20250806155741368](./assets/18_vue3源码学习.assets/image-20250806155741368.png)

那么createRender函数在哪里呢

![image-20250806160518094](./assets/18_vue3源码学习.assets/image-20250806160518094.png)

最后创建render的函数是重载的最后一个函数，这个函数很大，有将近两千行代码

![image-20250806160644429](./assets/18_vue3源码学习.assets/image-20250806160644429.png)

最终返回了这样一个对象

![image-20250806160746538](./assets/18_vue3源码学习.assets/image-20250806160746538.png)

所以创建的函数就是这个了

![image-20250806160926567](./assets/18_vue3源码学习.assets/image-20250806160926567.png)

所以app的创建过程实际上就是通过createAppAPI这个函数创建的，这个函数还接受render函数和hydrate，hydrate是服务端渲染，可以不用管，render函数是在上面定义的

![image-20250806161214651](./assets/18_vue3源码学习.assets/image-20250806161214651.png)

所以其实最终调用的函数是createAppAPI的函数

![image-20250806161442847](./assets/18_vue3源码学习.assets/image-20250806161442847.png)

并且这个函数会返回了一个函数，所以我们在前面返回的是一个函数的调用

![image-20250806161633819](./assets/18_vue3源码学习.assets/image-20250806161633819.png)

我们前面看app有很多功能：

```js
app.directive()
app.components()
...
```

看起来很神秘，实际上app就是一个对象，只是定义了很多东西

![image-20250806162208507](./assets/18_vue3源码学习.assets/image-20250806162208507.png)

我们前面调了一下mount，所以我们看一下mount

![image-20250806162511835](./assets/18_vue3源码学习.assets/image-20250806162511835.png)

我们传入了#app

![image-20250806162840002](./assets/18_vue3源码学习.assets/image-20250806162840002.png)

但是为什么没有问题呢？

因为mount被重写了

![image-20250806163052832](./assets/18_vue3源码学习.assets/image-20250806163052832.png)

他是在这里拿到我们传入的#app并且创建了container

![image-20250806163131251](./assets/18_vue3源码学习.assets/image-20250806163131251.png)

做完以后拿到container之后再去执行了mount

![image-20250806163320402](./assets/18_vue3源码学习.assets/image-20250806163320402.png)

为什么要重写？为的是跨平台

接下来执行mount函数了

![image-20250806163540559](./assets/18_vue3源码学习.assets/image-20250806163540559.png)

当VNode创建出来以后就该渲染VNode了

![image-20250806163812073](./assets/18_vue3源码学习.assets/image-20250806163812073.png)

那么render函数是这里来的

![image-20250806164032144](./assets/18_vue3源码学习.assets/image-20250806164032144.png)

上面中，如果VNode是空的话，会做一个卸载的操作，如果不是空的话，会做一个patch的操作

我们的container因为是第一次挂载，所以实际上他的_vnode是一个空，也就是null，那传给patch的实际上也是一个空

所以就来到了patch的操作（patch还是在这个函数中）

![image-20250806164933830](./assets/18_vue3源码学习.assets/image-20250806164933830.png)

处理VNode

![image-20250806165255881](./assets/18_vue3源码学习.assets/image-20250806165255881.png)

因为我们传进来的一个app实际上是一个组件，所以按照处理组件类型来处理

![image-20250806165650445](./assets/18_vue3源码学习.assets/image-20250806165650445.png)

所以我们跳到这里来

![image-20250806171346129](./assets/18_vue3源码学习.assets/image-20250806171346129.png)

并且

![image-20250806171501507](./assets/18_vue3源码学习.assets/image-20250806171501507.png)

创建组件实例

![image-20250807085022661](./assets/18_vue3源码学习.assets/image-20250807085022661.png)

组件VNode和组件实例有什么区别？

组件的VNode是虚拟DOM

组件实例是保存组件的各种状态，包括data，methods等

初始上面这个instance都是为空的，返回的是一个对象

![image-20250807085354340](./assets/18_vue3源码学习.assets/image-20250807085354340.png)

可以看到，他们都是空的，那data，computed和生命周期这些在哪里赋值的呢？

![image-20250807090802570](./assets/18_vue3源码学习.assets/image-20250807090802570.png)

这里对他进行赋值

effect副作用函数

![image-20250807092354817](./assets/18_vue3源码学习.assets/image-20250807092354817.png)

挂载和更新

![image-20250807092643670](./assets/18_vue3源码学习.assets/image-20250807092643670.png)

生成组件的VNode

![image-20250807093059610](./assets/18_vue3源码学习.assets/image-20250807093059610.png)

生成subTree后会执行patch，这里执行patch实际上算是递归调用了，因为我们这里的调用是属于patch的

patch里面走的是Fragment

![image-20250807093730918](./assets/18_vue3源码学习.assets/image-20250807093730918.png)

挂载所有的子元素

![image-20250807094606407](./assets/18_vue3源码学习.assets/image-20250807094606407.png)

如果不是Fragment，那么就是挂载所有的元素

![image-20250807094303673](./assets/18_vue3源码学习.assets/image-20250807094303673.png)

![image-20250807094334117](./assets/18_vue3源码学习.assets/image-20250807094334117.png)

注意：上面和有多个根就有差异了，这里挂载的就是n2而不是n2.children了

因为Fragment是不需要挂载的，但是如果是元素比如div就需要挂载

不管是Fragment还是有根组件最终都要挂载元素

![image-20250807095456719](./assets/18_vue3源码学习.assets/image-20250807095456719.png)

![image-20250807095658509](./assets/18_vue3源码学习.assets/image-20250807095658509.png)

host是为了做跨平台的，这个函数实际上是为了做这个```const el = document.createElement('div')```

![image-20250807095925669](./assets/18_vue3源码学习.assets/image-20250807095925669.png)

如果还有子节点的话，递归的再次做挂载

当然挂载操作实际上是这样做的

![image-20250807100134179](./assets/18_vue3源码学习.assets/image-20250807100134179.png)

对每一个子元素进行遍历，然后进行挂载，当遇到子元素之后继续递归的调用mountElement后继续遍历...

当然，除了挂载元素，还需要对属性进行处理

![image-20250807100558978](./assets/18_vue3源码学习.assets/image-20250807100558978.png)

插入到app中

![image-20250807100733083](./assets/18_vue3源码学习.assets/image-20250807100733083.png)

以上就是挂载的所有流程，当执行完上面的东西之后，页面就能显示出来内容了

总结下来的话就是

![image-20250807104922111](./assets/18_vue3源码学习.assets/image-20250807104922111.png)

接下来看一下创建组件实例的时候做了什么



### 组件的初始化过程

前面说过，创建组件实例是在这里

![image-20250807143245045](./assets/18_vue3源码学习.assets/image-20250807143245045.png)

这里的instance实际上只是一个对象，里面只是定义了一些属性，但是没有值，真正赋值的是在setupComponent这个函数里面，接下来看一下这个函数做了什么操作

进入setupComponent函数

![image-20250807150904693](./assets/18_vue3源码学习.assets/image-20250807150904693.png)

我们传进来的是一个有状态的组件，然后开始初始化props和slots

这个props还会处理attributes

因为我们需要对插槽做一个渲染，所以这里初始化了插槽

然后接着执行了setup

![image-20250807151356155](./assets/18_vue3源码学习.assets/image-20250807151356155.png)

![image-20250807151251234](./assets/18_vue3源码学习.assets/image-20250807151251234.png)

如果setup有值的话

![image-20250807151548352](./assets/18_vue3源码学习.assets/image-20250807151548352.png)

这个函数其实就是执行了setup

![image-20250807151633217](./assets/18_vue3源码学习.assets/image-20250807151633217.png)

处理setup函数的返回值

![image-20250807151840285](./assets/18_vue3源码学习.assets/image-20250807151840285.png)

setup返回值的处理

![image-20250807152036675](./assets/18_vue3源码学习.assets/image-20250807152036675.png)

proxyRefs这个实际上是做了一个代理

所以我们如果要取setup返回值的话是要从instance.setupState中取的

紧接着会调用这个函数

![image-20250807152303392](./assets/18_vue3源码学习.assets/image-20250807152303392.png)

他做的事情是编译template

![image-20250807152438372](./assets/18_vue3源码学习.assets/image-20250807152438372.png)

这里先调用了compiler，然后赋值给Component.render然后又赋值给了instance.render

还是这个函数继续往下来判断要不要支持vue2的options api

![image-20250807152637652](./assets/18_vue3源码学习.assets/image-20250807152637652.png)

在applyOptions函数中能看到vue2的options api的创建

![image-20250807152751089](./assets/18_vue3源码学习.assets/image-20250807152751089.png)

做完上面那些其实就是已经对setup的操作执行完了





## 源码阅读之挂载根组件

![image-20250806141055052](./assets/18_vue3源码学习.assets/image-20250806141055052.png)





```js
const app = {props: {message: String}
instance
// 1.处理props和attrs
instance.props
instance.attrs
             
// 2.处理slots
instance.slots
             
// 3.执行setup
const result = setup()
instance.setupState = proxyRefs(result);

// 4.编译template -> compile
<template> -> render函数
instance.render = Component.render = render函数

// 5.对vue2的options api进行知识
data/methods/computed/生命周期
```







## 组件化的初始化

![image-20250806141254026](./assets/18_vue3源码学习.assets/image-20250806141254026.png)





## Compile过程

把template转成render函数

![image-20250807153333053](./assets/18_vue3源码学习.assets/image-20250807153333053.png)

![image-20250807153613867](./assets/18_vue3源码学习.assets/image-20250807153613867.png)

render函数长的就是这个样子

![image-20250807153645080](./assets/18_vue3源码学习.assets/image-20250807153645080.png)

通过compiler就是把template转成了上面这样

![image-20250807153756850](./assets/18_vue3源码学习.assets/image-20250807153756850.png)



compile的解析

![image-20250807154347791](./assets/18_vue3源码学习.assets/image-20250807154347791.png)

先看这幅图的左下画图部分，把一个C语言转成python代码要怎么做呢？

- 先通过parser对代码进行解析，例如词法分析，语法分析等
- 生成C语言的AST树
- 解析C语言的AST树生成python的AST树
- 生成代码
- 生成后的python代码

再看上面的画图部分，其实我们的模板也是和不同语言的转换是一样的

- 先对template进行parser，这里面也是做词法分析，语法分析
- 生成AST树，这个AST树实际上是html的AST树
- 通过生成的AST再生成JS的AST树
- 通过JS AST树生成render函数

这种操作，其实就是编译器做的事情，compile可以理解为就是编译器

接下来看一下compile函数

跳到compile函数

![image-20250807155509043](./assets/18_vue3源码学习.assets/image-20250807155509043.png)

实际上执行的是registerRuntimeCompiler函数，搜索这个函数

![image-20250807160649959](./assets/18_vue3源码学习.assets/image-20250807160649959.png)

找到compileToFunction函数

实际上就是这个函数了

![image-20250807162457610](./assets/18_vue3源码学习.assets/image-20250807162457610.png)

所以在前面给compile函数传入的参数，也就是传到了上面这个函数里面了

这个函数又调了这个compile

![image-20250807162820342](./assets/18_vue3源码学习.assets/image-20250807162820342.png)

这个函数实际上是这里的

![image-20250807162857886](./assets/18_vue3源码学习.assets/image-20250807162857886.png)

跳到baseCompile函数中

![image-20250807163129011](./assets/18_vue3源码学习.assets/image-20250807163129011.png)

generate生成的就是render函数

![image-20250807163311564](./assets/18_vue3源码学习.assets/image-20250807163311564-1754555592446-1.png)

vue3的编译和diff算法对比vue2做了更新，性能会更好了，就是因为引入了block tree

![image-20250807163508217](./assets/18_vue3源码学习.assets/image-20250807163508217.png)



## Block Tree分析

![image-20250806141310927](./assets/18_vue3源码学习.assets/image-20250806141310927.png)

![image-20250807164520917](./assets/18_vue3源码学习.assets/image-20250807164520917.png)

上面的createVNode就可以理解为h函数

![image-20250807164920195](./assets/18_vue3源码学习.assets/image-20250807164920195.png)

仔细看上面这个render函数，他返回的里面调用了_createBlock，这个函数可以理解为h函数，第一个参数是Fragment，因为我们没有根，所以用Fragment，因为没有属性，所以第二个参数是null，然后第三个参数是children，这里是一个数组，数组的第一项是coderwhy这个div，第二个参数是coderwhy这个h2，第三个是message，第四个是button

这个render函数执行后生成了VNode，那么这个render函数在哪里调用的呢？

先来看组件是怎么挂载的，组件其实不会挂载挂载的是组件中的dom元素，来到这里

![image-20250807170551042](./assets/18_vue3源码学习.assets/image-20250807170551042.png)

这个函数执行挂载的一些操作

![image-20250807165737593](./assets/18_vue3源码学习.assets/image-20250807165737593.png)

这里就是生成VNode，进入到renderComponentRoot函数中

这个函数里面可以从instance结构出来render函数

![image-20250807170737813](./assets/18_vue3源码学习.assets/image-20250807170737813.png)

什么时候添加进去的呢？

在mountComponent函数中执行了这个函数

![image-20250807171014666](./assets/18_vue3源码学习.assets/image-20250807171014666.png)

执行了这个函数

![image-20250807171053077](./assets/18_vue3源码学习.assets/image-20250807171053077.png)

执行了这个函数

![image-20250807171125806](./assets/18_vue3源码学习.assets/image-20250807171125806.png)

执行了这个函数

![image-20250807171151502](./assets/18_vue3源码学习.assets/image-20250807171151502.png)

在这个函数中加入的render函数

![image-20250807171238581](./assets/18_vue3源码学习.assets/image-20250807171238581.png)

所以我们在这里能结构出来render函数

![image-20250807171338453](./assets/18_vue3源码学习.assets/image-20250807171338453.png)

进入到stupRenderEffect函数

![image-20250807171433925](./assets/18_vue3源码学习.assets/image-20250807171433925.png)

进入到renderComponentRoot函数

![image-20250807171501568](./assets/18_vue3源码学习.assets/image-20250807171501568.png)

这里的render是有值的

![image-20250807171735126](./assets/18_vue3源码学习.assets/image-20250807171735126.png)

最终把这个result返回了

![image-20250807171816494](./assets/18_vue3源码学习.assets/image-20250807171816494.png)

这里我们就可以拿到子树了

![image-20250807171908303](./assets/18_vue3源码学习.assets/image-20250807171908303.png)

然后挂载子树

![image-20250807171957836](./assets/18_vue3源码学习.assets/image-20250807171957836.png)

进入patch后就会对每一个子元素进行遍历，判断类型，然后生成真实dom，然后插入

我们需要知道vue的更新是组件级别的

![image-20250807174532423](./assets/18_vue3源码学习.assets/image-20250807174532423.png)

点击按钮，那么会更新

![image-20250807174629023](./assets/18_vue3源码学习.assets/image-20250807174629023.png)

来到更新组件，因为我们已经挂载过了

![image-20250807174643149](./assets/18_vue3源码学习.assets/image-20250807174643149.png)

就会重新render

![image-20250807174741408](./assets/18_vue3源码学习.assets/image-20250807174741408.png)

这个函数就会重新执行

![image-20250807174911846](./assets/18_vue3源码学习.assets/image-20250807174911846.png)

然后再次生成一个render函数，并且重新执行

![image-20250807175350354](./assets/18_vue3源码学习.assets/image-20250807175350354.png)

对于不变的dom，更新的时候就不用重新生成，对他们做了一个作用域提升，下一次更新的时候直接引用就行了

![image-20250807175849838](./assets/18_vue3源码学习.assets/image-20250807175849838.png)

![image-20250807180121241](./assets/18_vue3源码学习.assets/image-20250807180121241.png)

这样就意味着，在diff的时候diff dynamicChildren就行了，其他的静态元素就不需要diff算法了

注意：上面先调用了openBlock函数，这个函数就是帮助我们完成把p元素和h2元素放到dynamicChildren中的操作

更新组件的时候，会先看看block有没有值

![image-20250807180550634](./assets/18_vue3源码学习.assets/image-20250807180550634.png)

如果有值就patchBlockChildren

有一点误解，render函数其实只会生成一次，到更新的时候还是使用第一次编译出来的render函数，第一个，第二个vnode引用的还是第一次编译的，第三个和第四个是重新生成的





## 生命周期回调

![image-20250806141318214](./assets/18_vue3源码学习.assets/image-20250806141318214.png)

![image-20250808084741797](./assets/18_vue3源码学习.assets/image-20250808084741797.png)

我们写的这些生命周期到底是在哪里回调的呢？

对vue2的生命周期处理是在这里

![image-20250808090158766](./assets/18_vue3源码学习.assets/image-20250808090158766.png)

![image-20250808090358896](./assets/18_vue3源码学习.assets/image-20250808090358896.png)

![image-20250808090424015](./assets/18_vue3源码学习.assets/image-20250808090424015.png)

对vue2的处理是在这里

![image-20250808090545935](./assets/18_vue3源码学习.assets/image-20250808090545935.png)

![image-20250808091821243](./assets/18_vue3源码学习.assets/image-20250808091821243.png)

因为这两个生命周期会在applyOptions中直接调用

![image-20250808091919412](./assets/18_vue3源码学习.assets/image-20250808091919412.png)

他会在执行完setup后执行了applyOptions，所以setup执行的顺序是大于beforeCreated和created

![image-20250808092259306](./assets/18_vue3源码学习.assets/image-20250808092259306.png)

初始的时候会执行这里面的代码，执行beforeCreate

![image-20250808092402802](./assets/18_vue3源码学习.assets/image-20250808092402802.png)

![image-20250808092551433](./assets/18_vue3源码学习.assets/image-20250808092551433.png)

因为callSyncHook传入的是beforeCreate，所以这里执行了beforeCreate

![image-20250808092728888](./assets/18_vue3源码学习.assets/image-20250808092728888.png)

created的调用

![image-20250808092838693](./assets/18_vue3源码学习.assets/image-20250808092838693.png)

所以beforeCreate和created都是在组件创建之后调用的

![image-20250808093028111](./assets/18_vue3源码学习.assets/image-20250808093028111.png)

放到这些生命周期之后在哪里处理的呢？

![image-20250808093313745](./assets/18_vue3源码学习.assets/image-20250808093313745.png)

这些onBeforeMount是通过createHook创建出来的

![image-20250808093608065](./assets/18_vue3源码学习.assets/image-20250808093608065.png)

实际上调用的是injectHook创建的

对传入的hook做处理后把这个生命周期进行了返回

![image-20250808093734834](./assets/18_vue3源码学习.assets/image-20250808093734834.png)

这样就进行了对我们写的生命周期做了一个注册

那么会在哪里调用呢？

![image-20250808094125482](./assets/18_vue3源码学习.assets/image-20250808094125482.png)

![image-20250808094305498](./assets/18_vue3源码学习.assets/image-20250808094305498.png)

这个是beforeMount的生命周期执行，刺客还没有挂载，这个函数执行完了以后，就会通过patch进行挂载了

![image-20250808094826233](./assets/18_vue3源码学习.assets/image-20250808094826233.png)

调用队列中所有的函数

![image-20250808095249134](./assets/18_vue3源码学习.assets/image-20250808095249134.png)

![image-20250808095517974](./assets/18_vue3源码学习.assets/image-20250808095517974.png)

![image-20250808095439306](./assets/18_vue3源码学习.assets/image-20250808095439306.png)

beforeUpdate、updated和beforeMounted、mounted是一样的逻辑

![image-20250808095716843](./assets/18_vue3源码学习.assets/image-20250808095716843.png)

![image-20250808095829738](./assets/18_vue3源码学习.assets/image-20250808095829738.png)

![image-20250808095918913](./assets/18_vue3源码学习.assets/image-20250808095918913.png)

以上就是生命周期的调用位置





## template中数据的使用顺序

![image-20250806141325332](./assets/18_vue3源码学习.assets/image-20250806141325332.png)

![image-20250808100402668](./assets/18_vue3源码学习.assets/image-20250808100402668.png)

两个相同名字的响应式数据，优先级是什么呢？

最终渲染的是setup中的message，为什么呢？

![image-20250808100854713](./assets/18_vue3源码学习.assets/image-20250808100854713.png)

所以现在要确定这个_ctx是谁就能确定template中渲染的message来自哪里了

![image-20250808101303139](./assets/18_vue3源码学习.assets/image-20250808101303139.png)

![image-20250808101528107](./assets/18_vue3源码学习.assets/image-20250808101528107.png)

那么这个proxy来自哪里呢？

![image-20250808102203597](./assets/18_vue3源码学习.assets/image-20250808102203597.png)

![image-20250808102255711](./assets/18_vue3源码学习.assets/image-20250808102255711.png)

![image-20250808102321498](./assets/18_vue3源码学习.assets/image-20250808102321498.png)

proxy的get和set在PublicInstanceProxyHandlers里面

![image-20250808103352915](./assets/18_vue3源码学习.assets/image-20250808103352915.png)

![image-20250808103802341](./assets/18_vue3源码学习.assets/image-20250808103802341.png)

![image-20250808104132220](./assets/18_vue3源码学习.assets/image-20250808104132220.png)

然后再setupState中判断有没有这个属性，如果有的话，就返回setupState中的这个属性

这就是为什么，setup有值的话，就是用setup中的值
