

## Vue3源码学习



## 真实的DOM渲染

我们传统的前端开发中，我们是编写自己的HTML，形成一个dom树，浏览器识别到我们的dom树，最终被渲染到浏览器上的，那么它是什么样的过程呢？

![image-20250731220136023](./18、vue3源码学习.assets/image-20250731220136023.png)





## 虚拟DOM的优势

目前框架都会引入虚拟DOM来对真实的DOM进行抽象，这样做有很多的好处：

首先是可以对真实的元素节点进行抽象，抽象成VNode（虚拟节点），这样方便后续对其进行各种操作： 

- 因为对于直接操作DOM来说是有很多的限制的，比如diff、clone等等(element的属性太多了)，但是使用JavaScript编程语言来操作这 些，就变得非常的简单； 
- 我们可以使用JavaScript来表达非常多的逻辑，而对于DOM本身来说是非常不方便的；

其次是方便实现跨平台，包括你可以将VNode节点渲染成任意你想要的节点 

- 如渲染在canvas、WebGL、SSR、Native（iOS、Android）上； 
- 并且Vue允许你开发属于自己的渲染器（renderer），在其他的平台上渲染；

实现跨平台，将一些虚拟dom转成控件，比如ios，安卓，button控件（安卓），或者uibutton控件（ios）

vue源码比较复杂，但是本质上做的就是这个事情





## 虚拟DOM的渲染过程

![image-20250731220456886](./18、vue3源码学习.assets/image-20250731220456886.png)

![image-20250731220501875](./18、vue3源码学习.assets/image-20250731220501875.png)





## 三大核心系统

事实上Vue的源码包含三大核心： 

- Compiler模块：编译模板系统（把template中的代码编译成render函数生成虚拟节点）； 
-  Runtime模块：也可以称之为Renderer模块，真正渲染的模块； 
- Reactivity模块：响应式系统；

![image-20250731220518638](./18、vue3源码学习.assets/image-20250731220518638.png)

![image-20250731220524050](./18、vue3源码学习.assets/image-20250731220524050.png)





## 三大系统协同工作

三个系统之间如何协同工作呢：

![image-20250731220638651](./18、vue3源码学习.assets/image-20250731220638651.png)





## 实现Mini-Vue

这里我们实现一个简洁版的Mini-Vue框架，该Vue包括三个模块： 

- 渲染系统模块； 
- 可响应式系统模块； 
- 应用程序入口模块；



./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./render.js"></script>
  <script>
    // 1.通过h函数来创建一个vnode
    const vnode = h('div', {class: 'wts'}, [
      h('h2', null, 'hello world'),
      h('p', null, 'this is a paragraph')
    ])
  </script>
</body>
</html>
```

首先实现h函数

./render.js

```js
const h = (tag, props, children) => {
  // 返回的就是vnode对象
  return {
    tag,
    props,
    children
  }
}
```

上面已经实现了h函数

这就是我们的vnode了

![image-20250801201650061](./18、vue3源码学习.assets/image-20250801201650061.png)

上面就是虚拟dom了

接下来需要把虚拟节点转换成真实dom，并且展示在页面

./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>
  <script src="./render.js"></script>
  <script>
    // 1.通过h函数来创建一个vnode
    const vnode = h('div', {class: 'wts'}, [
      h('h2', null, 'hello world'),
      h('p', null, 'this is a paragraph')
    ])
    console.log(vnode);

    // 2.通过mount函数将vnode怪哉到div#app上
    mount(vnode, document.querySelector('#app'));
  </script>
</body>
</html>
```

./render.js

```js
const h = (tag, props, children) => {
  // 返回的就是vnode对象
  return {
    tag,
    props,
    children
  }
}

const mount = (vnode, container) => {
  // vnode保留一份真实的DOM元素
  const el = vnode.el = document.createElement(vnode.tag);

  // 设置属性
  if (vnode.props) {
    for (const key in vnode.props) {
      const value = vnode.props[key];
      // 如果是事件监听器
      if (key.startsWith('on')) {
        el.addEventListener(key.slice(2).toLowerCase(), value)
      } else {
        // 普通属性
        el.setAttribute(key, value)
      }
      
    }
  }

  // 3.处理子节点
  if (vnode.children) {
    if (typeof vnode.children === 'string') {
      // 如果是文本节点
      el.textContent = vnode.children;
    } else {
      // 如果是数组节点
      vnode.children.forEach(child => {
        mount(child, el);
      });
    }
  }

  // 4.将el添加到容器中
  container.appendChild(el);
}
```



 

目录结构

![image-20210627195127711](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627195127711.png)

h函数

![image-20210627195205307](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627195205307.png)

这里是渲染函数，拿到vnode

![image-20210627195151286](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627195151286.png)

长这么样，vnode里面还会有vnode

![image-20210627195352196](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627195352196.png)



把上面的虚拟dom转成真实dom，怎么做呢？

![image-20210627195818607](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627195818607.png)

![image-20210627195830314](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627195830314.png)



增加props（attribute）， 事件、子元素

![image-20210627201059026](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627201059026.png)

上面的写完以后，页面就可以展示了

![image-20210627201126745](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627201126745.png)

如果有新的vnode

![image-20210627213932839](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627213932839.png)



它们就需要通过diff比较

![image-20210627213959848](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627213959848.png)

![image-20210627214348622](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627214348622.png)



判断

![image-20210627214552017](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627214552017.png)



拿到它，然后把他替换掉，替换为h2

![image-20210627214538848](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627214538848.png)



这里我们的n2是h2标签

![image-20210627215251995](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627215251995.png)

![image-20210627215340784](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627215340784.png)

页面就变了

![image-20210627215353480](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627215353480.png)

接下来处理props

![image-20210627221056226](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627221056226.png)



处理attr

![image-20210627221357764](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627221357764.png)

![image-20210627221457682](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627221457682.png)



![image-20210628202632078](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628202632078.png)

![image-20210628202700930](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628202700930.png)

现在考虑的情况做完了

![image-20210628203124486](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628203124486.png)

![image-20210628203159265](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628203159265.png)

现在可以看到，这里已经改了，是没有问题的

可见，这里如果改了，是可以做diff算法的



下面开始做响应式系统

![image-20210628205401885](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628205401885.png)

先实现一下这个代码

![image-20210628205735244](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628205735244.png)

上面这个counter有个问题，它不是响应式的。

![image-20210628210228273](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628210228273.png)





![image-20210628210218378](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628210218378.png)



![image-20210628222352379](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628222352379.png)



![image-20210628222453311](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628222453311.png)



![image-20210628222556480](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628222556480.png)



![image-20210628222643900](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628222643900.png)



上面的有缺点，增加依赖的函数需要我们手动添加到订阅者列表中，更新依赖后也需要手动调用Notify来更新 

![image-20210628223259389](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628223259389.png)

![image-20210628223450726](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628223450726.png)



剩下要做什么呢？我们目前的话是要把我们每一个依赖的传到里面去，但是接下来要做的是，我不传里面去，也把你添加到我的依赖表里面

![image-20210628224138957](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628224138957.png)

![image-20210628224734167](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628224734167.png)

![image-20210628224957623](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628224957623.png)

我们的代码改造了一下之后，依然可以达到这个效果

如果我们希望我们传入watchEffect的函数，默认就执行一次

![image-20210628225134123](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628225134123.png)



再增加一个

![image-20210628225442734](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628225442734.png)



现在的代码还有一个问题

假设我有一个name

![image-20210628225818120](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628225818120.png)

![image-20210628225923832](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628225923832.png)

![image-20210628230206764](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210628230206764.png)

也就是说foo.height发生变化的时候只有watchEffect4才执行

所以我们不能把所有的依赖都往一个dep.subscribers里面放，我们要有多个dep对象

![image-20210629202058795](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629202058795.png)

![image-20210629202149578](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629202149578.png)

![image-20210629202345373](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629202345373.png)



我们现在要对我们的代码做劫持，因为我们的数据假如改变了，   info.name="wts";  我们如何知道呢？

数据劫持有两种方式

definedProperty

![image-20210629203632759](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629203632759.png)

![image-20210629203732760](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629203732760.png)

![image-20210629203756268](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629203756268.png)

![image-20210629203816375](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629203816375.png)





![image-20210629205604233](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629205604233.png)



![image-20210629205657120](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629205657120.png)



![image-20210629210232900](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629210232900.png)



![image-20210629210438029](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629210438029.png)



![image-20210629210719706](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629210719706.png)

这个也不要了

![image-20210629211050924](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629211050924.png)

加上打印

![image-20210629211307185](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629211307185.png)

![image-20210629211453796](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629211453796.png)

这个也不要

![image-20210629211811069](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629211811069.png)

这里也需要改一下

![image-20210629212103294](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629212103294.png)

再增加一个

![image-20210629212149441](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629212149441.png)

![image-20210629212222446](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629212222446.png)

所以只有它们两个执行

![image-20210629214817331](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629214817331.png)



vue3

![image-20210629220501496](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629220501496.png)



![image-20210629220434486](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629220434486.png)

但是proxy修改的是一个新的对象

![image-20210629221154249](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629221154249.png)



![image-20210629221307166](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629221307166.png)



vue3是这样实现的

![image-20210629223205527](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629223205527.png)



![image-20210629223327025](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629223327025.png)



![image-20210629230202382](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629230202382.png)



![image-20210629230211037](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210629230211037.png)



上面的代码有一些地方是有错误的，找了很长时间，这里不在说出哪里有错，如果重新复习这里，自己找bug，对自己有帮助。如果找不出，可以来到mini_vue文件夹，这里可以找到



## 渲染系统实现

渲染系统，该模块主要包含三个功能： 

- 功能一：h函数，用于返回一个VNode对象； 
- 功能二：mount函数，用于将VNode挂载到DOM上； 
- 功能三：patch函数，用于对两个VNode进行对比，决定如何处理新的VNode；



## h函数 – 生成VNode

h函数的实现： 

- 直接返回一个VNode对象即可

![image-20210627173421181](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627173421181.png)









## Mount函数 – 挂载VNode

mount函数的实现：

第一步：根据tag，创建HTML元素，并且存储 到vnode的el中；

第二步：处理props属性 

- 如果以on开头，那么监听事件； 
- 普通属性直接通过 setAttribute 添加即可；

第三步：处理子节点 

- 如果是字符串节点，那么直接设置 textContent； 
- 如果是数组节点，那么遍历调用 mount 函 数；

![image-20210627173515275](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210627173515275.png)





## Patch函数 – 对比两个VNode

patch函数的实现，分为两种情况 

n1和n2是不同类型的节点： 

- 找到n1的el父节点，删除原来的n1节点的el； 
- 挂载n2节点到n1的el父节点上；

n1和n2节点是相同的节点： 

- 处理props的情况 
  - 先将新节点的props全部挂载到el上； 
  - 判断旧节点的props是否不需要在新节点上，如果不需要，那么删除对应的属性； 
- 处理children的情况
  - 如果新节点是一个字符串类型，那么直接调用 el.textContent = newChildren； 
  - 如果新节点不同一个字符串类型：
    - 旧节点是一个字符串类型 
      - 将el的textContent设置为空字符串； 
      - 就节点是一个字符串类型，那么直接遍历新节点，挂载到el上；
    - 旧节点也是一个数组类型 
      - 取出数组的最小长度； 
      - 遍历所有的节点，新节点和旧节点进行path操作； 
      - 如果新节点的length更长，那么剩余的新节点进行挂载操作； 
      - 如果旧节点的length更长，那么剩余的旧节点进行卸载操作；



## Patch的实现

<img src="C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204406389.png" alt="image-20210701204406389" style="zoom:50%;" />

![image-20210701204435893](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204435893.png)



## 依赖收集系统

<img src="C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204502334.png" alt="image-20210701204502334" style="zoom:50%;" />

<img src="C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204515819.png" alt="image-20210701204515819" style="zoom:50%;" />



## 响应式系统Vue2实现

<img src="C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204614470.png" alt="image-20210701204614470" style="zoom:50%;" />

<img src="C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204627762.png" alt="image-20210701204627762" style="zoom:50%;" />



## 响应式系统Vue3实现

<img src="C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204713444.png" alt="image-20210701204713444" style="zoom:50%;" />



## 为什么Vue3选择Proxy呢？

Object.definedProperty 是劫持对象的属性时，如果新增元素： 

- 那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理；

修改对象的不同： 

- 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截； 
- 而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截；

Proxy 能观察的类型比 defineProperty 更丰富 

- has：in操作符的捕获器； 
- deleteProperty：delete 操作符的捕捉器； 
- 等等其他操作；

Proxy 作为新标准将受到浏览器厂商重点持续的性能优化；

缺点：Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9



## 框架外层API设计

这样我们就知道了，从框架的层面来说，我们需要 有两部分内容： 

- createApp用于创建一个app对象； 
- 该app对象有一个mount方法，可以将根组件挂 载到某一个dom元素上；

<img src="C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204928370.png" alt="image-20210701204928370" style="zoom:50%;" />

## 源码阅读之createApp

![image-20210701204959844](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701204959844.png)



## 源码阅读之挂载根组件

![image-20210701205030456](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701205030456.png)





const app = {props: {message: String} 

instance 

// 1.处理props和attrs 

instance.props 

instance.attrs 

// 2.处理slots 

instance.slots 

// 3.执行setup 

const result = setup() 

instance.setupState = proxyRefs(result); 

// 4.编译template -> compile



## 组件化的初始化

![image-20210701210248198](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701210248198.png) 



## Compile过程

![image-20210701210305530](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701210305530.png)



## Block Tree分析

![image-20210701210323207](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701210323207.png)





## 生命周期回调

![image-20210701210347098](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701210347098.png)



## template中数据的使用顺序

![image-20210701210413003](C:\Users\小山\AppData\Roaming\Typora\typora-user-images\image-20210701210413003.png)



